### Lesson 3. LVM

### (предисловие) полезные утилиты

* df -Th # отображение свободного пространства и разделов

* du # отображает использование памяти файлом или папкой (рекурсивно)

* stat # выводит статус файла или всей файловой системы

* ncdu # статистика, каие файлы сколько памяти занимают  

* lsof # список открытых файлов (какие файлы используются какими процессами)

* fuser #

* fsck # исправление файловой системы

* mkfs.* # создание файловой системы 

* mount |  column -t # монтирование

### LVM
* В утилите LVM основные типы устройств - PVG - physical device . создаются из физич дисков ( команда pvcreate )
* virtual group - группа из PV, vgcreate
* LV - Logical Volume- это часть VG, доступная в виде блочного устройства.


* скачиваем необходимые пакеты
yum install lvm2 mdadm smartmontools (?) hdparm (?) gdisk

* смотрим список блочных устройств
lsblk

* sdb - неразеченный диск на 10Гб. Делаем из него Pv - physical Volume
pvcreate /dev/sdb

* создаем группу (vgotus - название)
vgcreate vgotus /dev/sdb
опционально можно указать количество extent-ов для создания "-s <PE (Phys Extent)size>"

* vgdisplay - просмотр всех групп

* pvdisplay - просмотр ифнормации о томах

* создаем том . помощь - lvcreate --help \ --longhelp
lvcreate -L 8G -n lvotus vgotus

-L - size
-n - name

* смотрим  - lvdisplay -v /dev/vgotus/lvotus

строка block device 253:2 - ссылка на блочное устройство divice mapper. 
как это провирить - cat /proc/devices | grep device-mapper, увидим у него код 253

* pvs = краткий pvdisplay
* lvs - быстрая статистика по томам

* создаем файловую систему на разделе 
mkfs.ext4 /dev/vgotus/lvotus

* монтируем наш LV после создания ФС (форматирования)
mount /dev/vgotus/lvotus /mnt

* добавляем второй том к нашему vg vgotus (это делается ДО создания LV). NB! /dev/sdc уже должен быть со статусом PV 
vgextend vgotus /dev/sdc

* создание LV с объемом = всему оставшемуся месту
lvcreate -l 100%FREE -n var vg0 # rest of VG

* увеличиваем на 2Гб объем существующего раздела - LV (но до манипуляций с ФС доп. объем не появится)
lvextend -L +2G /dev/vgotus/lvotus

* смотрим разделы (df - инфа о файловой системе)
df -h

* изменяем размер файловой системы
resize2fs /dev/vgotus/lvotus 10G

* vgscan - ищет все VG - volume groups

* vgchange - меняет атрибуты VG 
vgchange -ay #активировать VG

* удаление -  pvremove, vgremove, lvremove

### Config files

/etc/lvm - кэш конфигураций + рез. копии

/etc/lvm/lvm.conf - основн. конфиг для утилиты LVM

* восстановление из бэкапа /etc/lvm/archive. на каждую операцию с lvm создается бэкап.
делаем vgremove

vgcfgrestore VG_name --test -f /etc/lvm/archive/VG_archive_name00_000.vg # c ключом test будет только проверка конфига
lvscan # для валидации

### LVM snapshots

* Принцип: создание нового LV, зависимого от оригинального LV,
куда будут копироваться оригинальные блоки данных перед
тем, как в оригинальный том будут записаны новые блоки
данных.
*  Должно быть место в VG под snapshot
*  В результате при использовании снапшотов мы получаем
двойную запись → замедление дисковых операций
*  Удаление снапшота - быстрое, откат на снапшот - медленный.
*  Снапшот можно монтировать, и даже в read-write режиме

* NB! большое количетсов снапшотов очень тормозит систему
 
#### создаем свой снапшот

* создание снапшота - аналогично созданию LV. -L это предполагаемый размер (объем изменений). -s = snapshot
lvcreate -L 500M -s -n test-snap /dev/otus/test # test-snap = name ; /dev/otus/test = path

* восстановление данных из снапшота
 lvconvert --merge /dev/otus/test-snap

* удаление снапшота 
lvremove /dev/otus/test-snap

### Thin provision

    Overbooking для LVM: Возможность выделить места больше, чем
есть.
Используется в виртуализации и контейнеризации

    Принцип: создается основной LV (thin pool), после чего создаются
зависимые LV с указанием виртуального размера.
Основные команды:
````
 lvcreate -L 100G -T vg0/lv-thinpool # выделение месте под thin provision pool

# создание томов в thin poolб каждый виртуального размера 100Гб
 lvcreate -V 100G -T vg0/lv-thinpool -n lv1
 lvcreate -V 100G -T vg0/lv-thinpool -n lv2
 lvcreate -V 100G -T vg0/lv-thinpool -n lv3
````
 *  физически места все равно 100G на всех, так что за памятью следить надо самому

 ### LVM cache 

 Вынос часто используемых данных на SSD
*  В основном используется на десктопах
*  Суть в том, что добавляется кеш LV
*  Нельзя использовать снапшоты

* Очень краткая и ёмкая документация:
   http://man7.org/linux/man-pages/man7/lvmcache.7.html


### LVM  Mirror


Зеркалирование на уровне LVM.

1. создаем несколько томов
2. Объединяем в Volume Group
3. Создаем том с указанием, сколько поий будет хранится. 
Основные команды:
```` pvcreate /dev/sda /dev/sdb # созхдание физ тома
 vgcreate vg0 /dev/sda /dev/sdb #создание группы
 lvcreate -L 50M -m1 -n mirror vg0 # создание LV с параметром -м1 - зеркалирование 1 раз (всего 2 диска), режим mirror, имя группы
 ````
 * в итоге данные на vg0 будут записываться одновременно на sdb и sda

 ### LVM перенос данных
 * команда pvmove позволяет перемещать данные в активной системе
 * pvmove разбивает данные на секции и создает временное зеркало для переноса каждой секции

 * перенос всех данных с тома /dev/sdv другим томам в группе:
 ````
pvmove -b /dev/sdc
 ````
* в итоге все данные с этого диска будут перераспределены по дргуим дискам группы, а сам диск sdc станет пустым, его можно будет отключить/вытащить

### Файловые системы

Файловую систему можно разделить на четыре основных компонента:
* Именованное пространство (namespace) - то как вещи (файлы, директории)
представлены и организованы (иерархия)
* API - набор системных вызовов для навигации и управления объектами
* Модель безопасности - схемы для защиты, скрытия и разделения
информации
* Реализация - софт для переноса логической модели на “железо”

#### иерархия файловой системы

Основная документация: man hier
* Файловая система в linux (да и unix в целом) имеет иерархическую/древовидную организацию. Принято минимизировать
количество разделов в корне и размещать там стартовые ветки иерархий.
В корне мы обычно видим следующие каталоги:

/boot - информация необходимая для загрузки (в т.ч. файлы ядра)
/bin,/sbin - системные исполняемые файлы.
/etc - файлы конфигурации системы и приложений
/home - домашние каталоги пользователей
/var - динамически изменяемая информация (БД, Кэши, логи)
/tmp (tmpfs) - временные файлы
/lib[64] - системные библиотеки
/usr - пользовательские (или системные) программы.

* В современных системах имеет смысл выделять при установке:
  * / - 8G
  * /home - 8G
  * /var - 16G
  * Для приложений стоит выделять отдельные тома (например для mysql -
отдельный том в /var/lib/mysql)

#### псевдофайловые системы 

* /proc - в ней дублируется информация о запущенных прцессах

* /sys - в ей информациях о модулях ядра

По сути две виртуальный файловые системы, которые предоставляют некий
интерфейс от пользователя к ядру. А именно, /proc - к запущенным процессам,
а /sys - информацию об устройствах, модулях ядра, файловых системах и пр.

http://man7.org/linux/man-pages/man5/sysfs.5.html#NOTES



#### страничный кэш
Страничный кэш 
Параметры работы pdflush:
/proc/sys/vm/dirty_expire_centisecs - время жизни dirty data в памяти
/proc/sys/vm/dirty_background_ratio - объем кеша, занятого dirty data (% кеша)
/proc/sys/vm/dirty_ratio - объем кеша, занятого dirty data (% общей памяти)
/proc/sys/vm/dirty_writeback_centisecs - период работы pdflush
fsync() - системный вызов, записывающий все измененные данные для
конкретного файла на диск (man 2 fsync)
Сброс кешей:
````
sync
 echo 3 > /proc/sys/vm/drop_caches
````
### Block, superblock, inode , Hardlink

* Блок - минимальный адресуемый размер дискового пространства.
Исторически - 512 байт. Так же это минимально аллоцируемый
размер под файл.

* Суперблок - информация о файловой системе:
- размер ФС
- размер блока
- битмап занятых блоков
- расположение и размер групп блоков и таблиц inode
````
[root@otuslinux ~]# dumpe2fs -h /dev/sda2
````

#### Inode
NB! количество Inode в системе ограницено, забив все пустыми файлами, можно исчерпать русурсы. Место на диске будет, а возможность записать еще файл - нет

Inode (индексный дескриптор) - структура, содержащая информацию о файле:
- размер файла в байтах;
- идентификатор владельца файла;
- идентификатор группы-владельца файла;
- режим доступа к файлу, определяющий кто и какой доступ имеет к файлу;
- дополнительные системные и пользовательские флаги, которые
дополнительно могут ограничивать доступ к файлу и его модификацию;
- временные метки, отражающие время модификации индексного
дескриптора (ctime, changing time), время модификации содержимого файла
(mtime, modification time) и время последнего доступа к файлу (atime, access
time);
- счётчик для учёта количества жёстких ссылок на файл;
- указатели на физические блоки диска, в которых хранится содержимое
файла

Inode #2 - root
Директория - это такой-же файл, содержимое которого представляет индекс
(B-tree), содержащий имя файла (ключ) и номер inode (значение)
- порядок файлов в директории не гарантируется
- перечисление всех файлов - очень медленно, но доступ к любому быстрый

* просмотр количества использованных/доступных inode в разделах
````
df -i
````

* если инодов мало -> расширяем файловую систему
````
tune2fs -l /dev/vgotus/lvotus
````
#### файловые системы

* ext2 - исторически “стандартная” для Linux. файловая система
решавшая много ограничений своих предтечей - ext и minix.
Считается эталоном производительности. Поддерживается online
resize. НЕ журналируемая

* ext3 - Логическое продолжение ext2, расширены ограничения на
размер файлов и тома, добавлена возможность журналирования

* ext4 - Логическое продолжение ext3. Номинально сильно
увеличены ограничения на размер тома, по факту из коробки все
еще 4Тб на том, возможность хранить ext. attributes в Inode,
увеличение inode (128->256b), решен вопрос со вложенными
каталогами (>32000)

FS - высокопроизводительная журналируемая файловая система родом из
SGI (Silicon Graphics).
Преимущества 
+ динамическая аллокация
inode
+ дефрагментация на лету
+ потенциально лучшая
производительность
+ встроенные средства для
резервного
копирования/снапшотов
(xfsdump/xfsrestore)
+ “отсутствие” жестких
ограничений на размер
файловой системы

Недостатки
    - малая ремонтопригодность
    - выше вероятность сбоя из-за
    хранения большого
    количества данных в памяти.
    - невозможность уменьшить


### Журналирование
Журналирование
* Хранение логов изменения метаданных. Не гарантирует сохранение
данных, но гарантирует консистентность файловой системы. В результате
восстановление после сбоя - это "проигрывание" журнала вместо полного
fsck.
Для ext4 есть три варианта ( mount -o data= )
journal - пишем сначала в журнал, самый медленный метод
ordered - пишем сначала файловую систему, потом журнал
writeback - не гарантируется порядок изменений, в файле после сбоя может
появиться блок данных, который был до сбоя удалён; самый быстрый метод.

### опции ФС
Опции ФС
man mount; mount -o ; opt,opt=val /dev/dev /mountpoint
Самые распространенные: noatime ; data= ; user ; noexec ; noauto

### файл /etc/fstab

Это Конфигурационный файл, содержащий информацию о блочных устройствах,
файловых системах на них и о том, как они будут интегрированы в систему.

* просмотр UUID, этот параметр прописывается в fstab
````
blkid
````

* просмотр используемого места
````
ncdu  # ставится после установки пакета epel-release

ncdu / # просмотр раздела /
````
* Команда fuser -с точка монтирования выводит идентификаторы всех
процессов, обращающихся к файлам или каталогам указанной файловой
системы
````
[root@otuslinux ~]# fuser -с /usr
[root@otuslinux ~]# ps -fp “9182 3123”
````

#### починка сломанной ФС. Fsck

* Иногда мы можем получить ФС в непредсказуемом состоянии. Для починки
используется утилита fsck. При перезагрузке проверяем ФС из /etc/fstab.

* Если вы хотите проверить файловую систему вручную то вначале ее
необходимо отмонтировать, а затем уже запустить fsck:
````
[root@otuslinux ~]# umount /data
[root@otuslinux ~]# fsck -y /dev/sdc
````

* Журналируемые файловые системы проверяются быстрее за счет того, что
fsck проверяет только последние записанные данные.

#### tmpfs. ramfs. rootfs. initramfs.
https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt
* Всё это - методы предоставления доступа к кеширующему
механизму на уровне пользователя
````
[root@otuslinux ~]# mount -t tmpfs none /mnt -o size=100M
````
#### SWAP
swap
swap - это процесс когда страницы памяти копируются на заранее
размеченное место на диске. Делается это затем, чтобы освободить место в
памяти.
[root@otuslinux ~]# swapon --show
[root@otuslinux ~]# free -h
[root@otuslinux ~]# mkswap /dev/sdb
[root@otuslinux ~]# swapon[off] /dev/sdb
/proc/sys/vm/swappiness
vm.swappiness=1

